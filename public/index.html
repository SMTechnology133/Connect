<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CONNECT A lightweight group chat application</title>
<meta name="theme-color" content="teal"/>   

<style>  
/* --- YOUR ORIGINAL CSS — UNCHANGED --- */
:root{--bg:#f6f8fb;--card:#fff;--accent:#2563eb;--muted:#666}
html,body{height:100%;margin:0;font-family:georgia;background:var(--bg);color:teal;margin-top:1px;}
.app{max-width:1000px;margin:0 auto;height:100vh;border-radius:4px;overflow:hidden;grid-template-columns:1fr 320px;border:1px solid orange;}
.left{display:flex;flex-direction:column;height:100%;background:linear-gradient(to right, teal, maroon);}
header{padding:12px 16px;border-bottom:1px solid orange;align-items:center;gap:12px;color:teal;flex-shrink:0;}
.logo{font-weight:600;color:orange;font-size:26px}

.messages{
	flex:1;
	overflow-y:auto;
	padding:16px;
	display:flex;
	flex-direction:column;
	gap:8px;
	background:teal;
	}
	
.composer{border-top:1px solid orange;display:flex;gap:8px;align-items:center;padding:8px;flex-shrink:0;background:linear-gradient(to right,#ffffff55,#ffffff00)}
textarea{height:64px;border:1px solid orange;resize:none;padding:8px;border-radius:6px;width:100%;color:orange;background:maroon;}
button{background:orange;color:teal;border:1px solid gray;padding:6px 8px;border-radius:8px;cursor:pointer}
.right{padding:12px;background:#f0f0f0;border-left:1px solid teal;display:flex;flex-direction:column;gap:8px;height:100%;overflow:auto}
.avatar{width:50px;height:50px;border-radius:50%;overflow:hidden;background:#7c3aed;color:white;display:flex;align-items:center;justify-content:center;font-weight:600;border:1px solid orange;}
.avatar img{width:100%;height:100%;object-fit:cover;}

.msg{
	max-width:70%;
	padding:10px;
	margin:4px;
	border-radius:10px;
	background:gray;
	border:1px solid orange;
	color: orange;
	}
	
.msg.out{
	margin-left:auto;
	background:orange;
	border:1px solid white;
	color:teal;
	}
	
.meta.small{font-size:12px;color:var(--muted)}
.users-list{list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:8px}
.user-item{display:flex;align-items:center;gap:8px;padding:6px;border-radius:8px}
.small{font-size:13px;color:var(--muted)}
#asideModalOverlay{position:fixed;left:0;top:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.55);z-index:999}
#asideModal{background:gray;width:92%;max-width:360px;max-height:90vh;overflow:auto;border-radius:8px;padding:14px;border:1px solid orange;}
#closeAsideBtn{background:maroon;color:orange;width:100%;padding:10px;border-radius:5px;border:1px solid orange;}
@media(max-width:720px){.app{grid-template-columns:1fr;height:100vh;border-radius:0}.right{display:none}}
.file-link{display:inline-block;margin-top:6px;color:var(--accent);text-decoration:underline;cursor:pointer}
.picturee{width:30px;height:30px;border:1px solid orange;border-radius:20px;padding:1px;margin-top:6px;}
.file-name {font-size:13px;color:var(--muted);margin-top:6px;word-break:break-all;}
.system-row{display:flex;gap:8px;align-items:center;}
.system-text{font-size:13px;color:var(--muted);margin-left:6px;}
</style>  
</head>  

<body>
<div class="app" role="application">

    <!-- LEFT PANEL -->
    <div class="left">
        <header>
            <span class="logo">Connect</span>&nbsp;

            <button id="openAsideBtn" class="small">Status</button>&nbsp;
            <button id="liveBtn" class="small">Live Video Streaming</button>

            <div style="flex:1"></div>

            <!-- PROFILE AREA -->
            <div class="user" style="display:flex;align-items:center;gap:8px">
                <div id="myAvatar" class="avatar">A</div>
                <input id="avatarInput" type="file" accept="image/*" style="display:none">
                <button id="changePicBtn" class="small">Image</button>

                <input id="nameInput" placeholder="Your name"
                       style="padding:6px;border-radius:6px;border:1px solid orange;">
                <button id="setNameBtn" class="small">Set</button>
            </div>
        </header>

        <div id="messages" class="messages"></div>

        <div class="composer">
            <textarea id="textInput" placeholder="Write a message..."></textarea>
            <div style="display:flex;flex-direction:column;gap:6px">
                <button id="sendBtn">Send</button>
                <button id="clearBtn" class="small">Clear</button>
            </div>    
        </div>

        <input id="fileInput" type="file"
               style="color:orange;font-size:10px;background:gray;border-radius:4px;border:1px solid orange; padding:4px; margin:8px; text-align:center;"><br>
    </div>

    <!-- RIGHT PANEL -->
    <aside id="desktopAside" class="right">
        <div class="small">Connection</div>
        <div id="connStatus" class="small">Connecting...</div>
        <hr>
        <div class="small">People</div>
        <ul id="users" class="users-list"></ul>
        <hr>
        <div class="small">Typing</div>
        <div id="typing" class="small"></div>
        <footer style="margin-top:auto" class="small">
            Files stored in browser (IndexedDB). Server relays messages only.
        </footer>
    </aside>
</div>

<!-- MOBILE ASIDE -->
<div id="asideModalOverlay">
    <div id="asideModal">
        <button id="closeAsideBtn">Close</button>
        <div style="margin-top:12px">
            <div class="small">Connection</div>
            <div id="m_connStatus" class="small">Connecting...</div>
            <hr>
            <div class="small">People</div>
            <ul id="m_users" class="users-list"></ul>
            <hr>
            <div class="small">Typing</div>
            <div id="m_typing" class="small"></div>
        </div>
    </div>
</div>

<script src="https://cdn.socket.io/4.7.1/socket.io.min.js"></script>

<script>
/* FIXED FULL JS (patch-only, preserves structure & CSS) */

(async function(){

/* Helpers */
const uid = (p='id') => p+"-"+Date.now()+"-"+Math.random().toString(36).slice(2,8);

const initialsFrom = name =>
    name ? name.split(" ").map(s=>s[0]).join("").slice(0,2).toUpperCase() : "";

const colorFrom = name=>{
    if(!name) return "#7c3aed";
    const colors=['#7c3aed','#0ea5e9','#ef4444','#16a34a','#f97316','#8b5cf6'];
    let h=0; for(let c of name) h+=c.charCodeAt(0);
    return colors[h%colors.length];
};

// sanitize to remove control characters that cause the replacement char ()
function sanitizeText(s){
    if(!s || typeof s !== "string") return s || "";
    // remove control chars (U+0000 - U+001F, U+007F - U+009F)
    return s.replace(/[\u0000-\u001F\u007F-\u009F]/g, "").trim();
}

/* DOM refs */
const messagesEl = document.getElementById('messages');
const usersEl = document.getElementById('users');
const typingEl = document.getElementById('typing');
const connStatus = document.getElementById('connStatus');

const m_connStatus = document.getElementById('m_connStatus');
const m_users = document.getElementById('m_users');
const m_typing = document.getElementById('m_typing');

const nameInput = document.getElementById('nameInput');
const setNameBtn = document.getElementById('setNameBtn');
const fileInput = document.getElementById('fileInput');
const textInput = document.getElementById('textInput');
const sendBtn = document.getElementById('sendBtn');
const clearBtn = document.getElementById('clearBtn');

const openAsideBtn = document.getElementById('openAsideBtn');
const asideOverlay = document.getElementById('asideModalOverlay');
const closeAsideBtn = document.getElementById('closeAsideBtn');
const liveBtn = document.getElementById('liveBtn');

const myAvatarEl = document.getElementById('myAvatar');
const avatarInput = document.getElementById('avatarInput');
const changePicBtn = document.getElementById('changePicBtn');

openAsideBtn.onclick = ()=> asideOverlay.style.display = "flex";
closeAsideBtn.onclick = ()=> asideOverlay.style.display = "none";
liveBtn.onclick = ()=> window.open("https://videostream-ns46.onrender.com/","_blank");

/* Avatar set */
function setAvatar(dataURL){
    if(dataURL){
        myAvatarEl.innerHTML = `<img src="${dataURL}">`;
    } else {
        myAvatarEl.textContent = initialsFrom(name);
        myAvatarEl.style.background = colorFrom(name);
    }
}

changePicBtn.onclick = () => avatarInput.click();

avatarInput.onchange = e =>{
    const f = e.target.files[0];
    if(!f) return;
    const reader = new FileReader();
    reader.onload = ()=>{
        const dataURL = reader.result;
        localStorage.setItem("profile_pic_data", dataURL);
        storedAvatar = dataURL; // keep local var up to date
        setAvatar(dataURL);
        if(socket && socket.connected){
            // sanitize name before sending
            socket.emit("update-profile",{name: sanitizeText(name), avatar:dataURL});
        }
    };
    reader.readAsDataURL(f);
};

/* Load profile */
let name = sanitizeText(localStorage.getItem("enhanced_chat_name")) || ("User "+Math.floor(Math.random()*9999));
let storedAvatar = localStorage.getItem("profile_pic_data") || null;

nameInput.value = name;
setAvatar(storedAvatar);

/* FIXED: Set Name button: set avatar as well and emit profile update */
setNameBtn.onclick = () =>{
    name = sanitizeText(nameInput.value.trim()) || name;
    localStorage.setItem("enhanced_chat_name", name);

    // refresh avatar shown (use storedAvatar if any)
    if(storedAvatar){
        setAvatar(storedAvatar);
    } else {
        setAvatar(null);
    }

    if(socket && socket.connected){
        socket.emit("update-profile",{name: name, avatar: storedAvatar});
    }
};

/* IndexedDB */
const DB_NAME="enhanced_chat_db", DB_VER=1;

function openDb(){
    return new Promise((res,rej)=>{
        const r=indexedDB.open(DB_NAME,DB_VER);
        r.onupgradeneeded=e=>{
            let db=e.target.result;
            if(!db.objectStoreNames.contains("messages"))
                db.createObjectStore("messages",{keyPath:"id"});
            if(!db.objectStoreNames.contains("files"))
                db.createObjectStore("files",{keyPath:"id"});
        };
        r.onsuccess=()=>res(r.result);
        r.onerror=()=>rej(r.error);
    });
}

async function put(store,obj){
    const db=await openDb();
    return new Promise((res,rej)=>{
        const tx=db.transaction([store],'readwrite');
        tx.objectStore(store).put(obj);
        tx.oncomplete=()=>res(obj);
        tx.onerror=()=>rej(tx.error);
    });
}

async function getAll(store){
    const db = await openDb();
    return new Promise((res,rej)=>{
        const tx=db.transaction([store],'readonly');
        const out=[];
        tx.objectStore(store).openCursor().onsuccess=e=>{
            const cur=e.target.result;
            if(!cur) return res(out);
            out.push(cur.value);
            cur.continue();
        };
    });
}

async function getFile(id){
    const db = await openDb();
    return new Promise((res)=>{
        db.transaction(["files"],"readonly").objectStore("files")
            .get(id).onsuccess=e=> res(e.target.result?e.target.result.blob:null);
    });
}

/* load history from local IndexedDB */
const history = await getAll("messages");
history.sort((a,b)=>a.ts-b.ts);
history.forEach(m=> addMessageDOM(m));

/* socket io */
const socket = io();

/* Local helper to auto-mark a message read if visible */
async function markMessageReadIfVisible(msgId){
    if(document.visibilityState === "visible"){
        socket.emit("message-read", {
            messageId: msgId,
            reader: sanitizeText(name),
            avatar: storedAvatar || null,
            ts: Date.now()
        });
    }
}

socket.on("connect",()=>{
    connStatus.textContent="Connected";
    m_connStatus.textContent="Connected";
    // send join and ask server for history (server will send 'history' automatically on connect)
    socket.emit("join",{name: sanitizeText(name),avatar:storedAvatar});
});

socket.on("disconnect",()=>{
    connStatus.textContent="Disconnected";
    m_connStatus.textContent="Disconnected";
});

/* Users */
let users = {};

function renderUsers(){
    usersEl.innerHTML="";
    m_users.innerHTML="";

    for(const id in users){
        const u = users[id];

        const li=document.createElement("li");
        li.className="user-item";

        const av=document.createElement("div");
        av.className="avatar";
        if(u.avatar){
            av.innerHTML=`<img src="${u.avatar}">`;
        } else {
            av.textContent=initialsFrom(u.name);
            av.style.background=colorFrom(u.name);
        }

        const nm=document.createElement("div");
        nm.textContent = u.name;

        li.append(av,nm);

        usersEl.append(li);
        m_users.append(li.cloneNode(true));
    }
}

/* server-sent current user list */
socket.on("users-list", data=>{
    // sanitize server data defensively
    for(const k in data){
        if(data[k] && data[k].name) data[k].name = sanitizeText(data[k].name);
    }
    users = data || {};
    renderUsers();
});

/* user joined */
socket.on("user-joined", data=>{
    if(data && data.user){
        data.user.name = sanitizeText(data.user.name);
        users[data.id] = data.user;
        renderUsers();
        addSystem(`${data.user.name} joined`, data.user);
    }
});

/* user left */
socket.on("user-left", data=>{
    if(data && data.user){
        data.user.name = sanitizeText(data.user.name);
        delete users[data.id];
        renderUsers();
        addSystem(`${data.user.name} left`, data.user);
    }
});

/* profile updated */
socket.on("profile-updated",({id,user})=>{
    if(user && user.name) user.name = sanitizeText(user.name);
    users[id]=user;
    renderUsers();
});

/* typing */
let typingTimer=null;
textInput.oninput=()=>{
    socket.emit("typing");
    clearTimeout(typingTimer);
    typingTimer=setTimeout(()=>socket.emit("stop-typing"),1200);
};

socket.on("typing",({user})=>{
    if(user && user.name) user.name = sanitizeText(user.name);
    typingEl.textContent=`${user.name} is typing...`;
    m_typing.textContent=typingEl.textContent;
});
socket.on("stop-typing",()=>{
    typingEl.textContent="—";
    m_typing.textContent="—";
});

/* server history: when connecting the server will emit 'history' — a list of messages in memory (only server lifetime) */
socket.on("history", async messages=>{
    if(!Array.isArray(messages)) return;
    // store server messages in local IndexedDB and render (avoid duplicating existing)
    for(const msg of messages){
        // sanitize sender/name/text
        if(msg.sender) msg.sender = sanitizeText(msg.sender);
        if(msg.text) msg.text = sanitizeText(msg.text);

        // don't duplicate: attempt to store; put will replace existing by id
        await put("messages", msg);
    }
    // reload local messages and render again (simple approach)
    const local = await getAll("messages");
    local.sort((a,b)=>a.ts-b.ts);
    messagesEl.innerHTML = "";
    local.forEach(m=> addMessageDOM(m));
});

/* Receive text */
socket.on("chat-message", async msg=>{
    // sanitize
    if(msg.sender) msg.sender = sanitizeText(msg.sender);
    if(msg.text) msg.text = sanitizeText(msg.text);

    await put("messages", msg);
    addMessageDOM(msg);

    // auto-mark read if user is looking at chat
    markMessageReadIfVisible(msg.id);
});

/* Receive file + PREVIEW */
socket.on("file-message", async payload=>{
    // payload.arrayBuffer is expected; create Blob from it
    try {
        const blob = new Blob([payload.arrayBuffer], {type:payload.fileType || "application/octet-stream"});
        await put("files",{id:payload.fileId,blob});
    } catch (err){
        console.warn("Error creating/storing blob:", err);
    }

    const msg={
        id:payload.id,
        sender:sanitizeText(payload.sender),
        avatar:payload.avatar,
        fileId:payload.fileId,
        fileName:payload.fileName,
        fileType:payload.fileType,
        ts:payload.ts
    };

    await put("messages", msg);
    addMessageDOM(msg);

    // auto mark read if visible
    markMessageReadIfVisible(msg.id);
});

/* PREVIEW HANDLER */
function createPreview(fileName, fileType, blobURL){
    if(fileType && fileType.startsWith("image/")){
        return { html: `<img src="${blobURL}" style="max-width:200px;border-radius:6px;margin-top:6px;">`, name: fileName };
    }
    if(fileType && fileType.startsWith("video/")){
        return { html: `<video controls playsinline preload="metadata" style="max-width:200px;margin-top:6px;"><source src="${blobURL}" type="${fileType}">Your browser does not support the video tag.</video>`, name: fileName };
    }
    if(fileType && fileType.startsWith("audio/")){
        return { html: `<audio controls src="${blobURL}" style="margin-top:6px;"></audio>`, name: fileName };
    }
    if(fileType === "application/pdf"){
        return { html: `<iframe src="${blobURL}" style="width:200px;height:200px;border:1px solid orange;margin-top:6px;"></iframe>`, name: fileName };
    }

    return { html: `<a class="file-link" href="${blobURL}" download="${encodeURIComponent(fileName || "file")}">Download ${fileName || "file"}</a>`, name: fileName };
}

/* DOM messages */
async function addMessageDOM(m){
    // avoid rendering twice: check if message already exists in DOM by id data-attr
    if(document.querySelector(`[data-msgid="${m.id}"]`)) return;

    const box=document.createElement("div");
    box.className="msg "+(m.out ? "out":"in");
    box.setAttribute("data-msgid", m.id);

    const av=document.createElement("div");
    av.className="avatar";
    if(m.avatar){
        av.innerHTML=`<img src="${m.avatar}">`;
    } else {
        av.textContent=initialsFrom(m.sender);
        av.style.background=colorFrom(m.sender);
    }

    // message body container
    const contentWrap = document.createElement("div");
    contentWrap.style.display = "flex";
    contentWrap.style.flexDirection = "column";
    contentWrap.style.marginLeft = "8px";
    contentWrap.style.maxWidth = "100%";

    const meta=document.createElement("div");
    meta.className="meta small";
    meta.textContent = `${m.sender} · ${new Date(m.ts).toLocaleTimeString()}`;

    const body=document.createElement("div");
    body.style.marginTop="6px";
    body.style.wordBreak = "break-word";

    // text message
    if(m.text){
        const p = document.createElement("div");
        p.textContent = m.text;
        body.appendChild(p);
    }

    // file message preview
    if(m.fileId){
        const blob = await getFile(m.fileId);
        if(blob){
            const url = URL.createObjectURL(blob);
            const preview = createPreview(m.fileName, m.fileType, url);

            // filename + download anchor
            const nameDiv = document.createElement("div");
            nameDiv.className = "file-name";
            const a = document.createElement("a");
            a.textContent = m.fileName || "file";
            a.href = url;
            a.download = m.fileName || "file";
            a.className = "file-link";
            nameDiv.appendChild(a);

            // preview container
            const wrap = document.createElement("div");
            wrap.innerHTML = preview.html;

            body.appendChild(nameDiv);
            body.appendChild(wrap);

            // revoke object URL after a bit (to avoid early invalidation on some browsers)
            setTimeout(()=>{ try{ URL.revokeObjectURL(url); }catch(e){} }, 60 * 1000);
        } else {
            const noDiv = document.createElement("div");
            noDiv.textContent = m.fileName ? `File: ${m.fileName}` : "File received";
            body.appendChild(noDiv);
        }
    }

    // combine parts: avatar + content
    box.append(av);

    contentWrap.appendChild(meta);
    contentWrap.appendChild(body);
    box.append(contentWrap);

    // clicking a message will emit a read receipt (manual)
    box.onclick = () => {
        socket.emit("message-read", {
            messageId: m.id,
            reader: sanitizeText(name),
            avatar: storedAvatar || null,
            ts: Date.now()
        });
        // optional visual feedback: briefly highlight
        box.style.boxShadow = "0 0 0 2px rgba(255,255,255,0.08) inset";
        setTimeout(()=> box.style.boxShadow = "", 700);
    };

    messagesEl.append(box);

    messagesEl.scrollTop = messagesEl.scrollHeight;
}

/* System message that can include avatar when user joins/leaves/read */
function addSystem(text, user){
    const box=document.createElement("div");
    box.className="msg in"; // system messages appear as incoming style

    // create small avatar if user provided
    const av=document.createElement("div");
    av.className="avatar";
    if(user && user.avatar){
        av.innerHTML = `<img src="${user.avatar}">`;
    } else if (user && user.name){
        av.textContent = initialsFrom(user.name);
        av.style.background = colorFrom(user.name);
    } else {
        av.textContent = "S";
        av.style.background = "#444";
    }

    const wrapper = document.createElement("div");
    wrapper.style.display = "flex";
    wrapper.style.flexDirection = "column";
    wrapper.style.marginLeft = "8px";

    const meta = document.createElement("div");
    meta.className = "meta small";
    meta.textContent = user && user.name ? `${user.name} · ${new Date().toLocaleTimeString()}` : `System · ${new Date().toLocaleTimeString()}`;

    const t = document.createElement("div");
    t.className = "system-text";
    t.textContent = text;

    wrapper.appendChild(meta);
    wrapper.appendChild(t);

    box.appendChild(av);
    box.appendChild(wrapper);

    messagesEl.appendChild(box);
    messagesEl.scrollTop = messagesEl.scrollHeight;
}

/* Handle incoming read receipts by showing a small system message */
socket.on("message-read", data=>{
    if(!data) return;
    const reader = sanitizeText(data.reader || "Someone");
    const avatar = data.avatar || null;
    addSystem(`${reader} read a message`, { name: reader, avatar });
});

/* send */
sendBtn.onclick = async () =>{
    const text = sanitizeText(textInput.value.trim());
    const file = fileInput.files[0];

    if(!text && !file) return;

    /* file */
    if(file){
        const arrayBuffer = await file.arrayBuffer();
        const fileId = uid("file");
        const msgId = uid("msg");

        const payload={
            id:msgId,
            sender: sanitizeText(name),
            avatar: storedAvatar,
            fileId,
            fileName:file.name,
            fileType:file.type,
            ts:Date.now(),
            arrayBuffer
        };

        // store file locally and message locally then emit
        await put("files",{id:fileId, blob:file});
        await put("messages",{...payload,out:true});
        addMessageDOM({...payload,out:true});

        socket.emit("file-message",payload);
    }

    /* text */
    if(text){
        const msg={
            id:uid("msg"),
            sender:sanitizeText(name),
            avatar:storedAvatar,
            text,
            ts:Date.now(),
            out:true
        };
        await put("messages",msg);
        addMessageDOM(msg);
        socket.emit("chat-message",msg);
        textInput.value="";
    }

    fileInput.value="";
};

/* Clear */
clearBtn.onclick = async () =>{
    if(!confirm("Clear local messages?")) return;
    const db = await openDb();
    const tx=db.transaction(["messages","files"],"readwrite");
    tx.objectStore("messages").clear();
    tx.objectStore("files").clear();
    tx.oncomplete=()=> messagesEl.innerHTML="";
};

/* when page becomes visible, emit read for all messages we haven't read yet (simple approach) */
document.addEventListener("visibilitychange", async ()=>{
    if(document.visibilityState === "visible"){
        // mark all messages in local DB as read by emitting message-read for each message id
        const local = await getAll("messages");
        for(const m of local){
            socket.emit("message-read", {
                messageId: m.id,
                reader: sanitizeText(name),
                avatar: storedAvatar || null,
                ts: Date.now()
            });
        }
    }
});

})();
</script>

</body>
</html>