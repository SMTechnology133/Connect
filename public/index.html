<!doctype html>  
<html lang="en">  
<head>  
<meta charset="utf-8" />  
<meta name="viewport" content="width=device-width,initial-scale=1" />  
<title>CONNECT A lightweight group chat application</title>  
<meta name="theme-color" content="teal"/>     
  
<style>    
/* --- YOUR ORIGINAL CSS — UNCHANGED --- */  
:root{--bg:#f6f8fb;--card:#fff;--accent:#2563eb;--muted:#666}  
html,body{height:100%;margin:0;font-family:georgia;background:var(--bg);color:teal;margin-top:1px;}  
.app{max-width:1000px;margin:0 auto;height:100vh;border-radius:4px;overflow:hidden;grid-template-columns:1fr 320px;border:1px solid orange;}  
.left{display:flex;flex-direction:column;height:100%;background:linear-gradient(to right, teal, maroon);}  
header{padding:12px 16px;border-bottom:1px solid orange;align-items:center;gap:12px;color:teal;flex-shrink:0;}  
.logo{font-weight:600;color:orange;font-size:26px}  
  
.messages{  
	flex:1;  
	overflow-y:auto;  
	padding:16px;  
	display:flex;  
	flex-direction:column;  
	gap:8px;  
	background:teal;  
	}  
	  
.composer{border-top:1px solid orange;display:flex;gap:8px;align-items:center;padding:8px;flex-shrink:0;background:linear-gradient(to right,#ffffff55,#ffffff00)}  
textarea{height:64px;border:1px solid orange;resize:none;padding:8px;border-radius:6px;width:100%;color:orange;background:maroon;}  
button{background:orange;color:teal;border:1px solid gray;padding:6px 8px;border-radius:8px;cursor:pointer}  
.right{padding:12px;background:#f0f0f0;border-left:1px solid teal;display:flex;flex-direction:column;gap:8px;height:100%;overflow:auto}  
.avatar{width:50px;height:50px;border-radius:50%;overflow:hidden;background:#7c3aed;color:white;display:flex;align-items:center;justify-content:center;font-weight:600;border:1px solid orange;}  
.avatar img{width:100%;height:100%;object-fit:cover;}  
  
.msg{  
	max-width:70%;  
	padding:10px;  
	margin:4px;  
	border-radius:10px;  
	background:gray;  
	border:1px solid orange;  
	color: orange;  
	}  
	  
.msg.out{  
	margin-left:auto;  
	background:orange;  
	border:1px solid white;  
	color:teal;  
	}  
	  
.meta.small{font-size:12px;color:var(--muted)}  
.users-list{list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:8px}  
.user-item{display:flex;align-items:center;gap:8px;padding:6px;border-radius:8px}  
.small{font-size:13px;color:var(--muted)}  
#asideModalOverlay{position:fixed;left:0;top:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.55);z-index:999}  
#asideModal{background:gray;width:92%;max-width:360px;max-height:90vh;overflow:auto;border-radius:8px;padding:14px;border:1px solid orange;}  
#closeAsideBtn{background:maroon;color:orange;width:100%;padding:10px;border-radius:5px;border:1px solid orange;}  
@media(max-width:720px){.app{grid-template-columns:1fr;height:100vh;border-radius:0}.right{display:none}}  
.file-link{display:inline-block;margin-top:6px;color:var(--accent);text-decoration:underline;cursor:pointer}  
.picturee{width:30px;height:30px;border:1px solid orange;border-radius:20px;padding:1px;margin-top:6px;}  
.file-name {font-size:13px;color:var(--muted);margin-top:6px;word-break:break-all;}  
.system-row{display:flex;gap:8px;align-items:center;}  
.system-text{font-size:13px;color:var(--muted);margin-left:6px;}  
</style>    
</head>    
  
<body>  
<div class="app" role="application">  
  
    <!-- LEFT PANEL -->  
    <div class="left">  
        <header>  
            <span class="logo">Connect</span>&nbsp;  
  
            <button id="openAsideBtn" class="small">Status</button>&nbsp;  
            <button id="liveBtn" class="small">Live Video Streaming</button>  
  
            <div style="flex:1"></div>  
  
            <!-- PROFILE AREA -->  
            <div class="user" style="display:flex;align-items:center;gap:8px">  
                <div id="myAvatar" class="avatar">A</div>  
                <input id="avatarInput" type="file" accept="image/*" style="display:none">  
                <button id="changePicBtn" class="small">Image</button>  
  
                <input id="nameInput" placeholder="Your name"  
                       style="padding:6px;border-radius:6px;border:1px solid orange;">  
                <button id="setNameBtn" class="small">Set</button>  
            </div>  
        </header>  
  
        <div id="messages" class="messages"></div>  
  
        <div class="composer">  
            <textarea id="textInput" placeholder="Write a message..."></textarea>  
            <div style="display:flex;flex-direction:column;gap:6px">  
                <button id="sendBtn">Send</button>  
                <button id="clearBtn" class="small">Clear</button>  
            </div>      
        </div>  
  
        <input id="fileInput" type="file"  
               style="color:orange;font-size:10px;background:gray;border-radius:4px;border:1px solid orange; padding:4px; margin:8px; text-align:center;"><br>  
    </div>  
  
    <!-- RIGHT PANEL -->  
    <aside id="desktopAside" class="right">  
        <div class="small">Connection</div>  
        <div id="connStatus" class="small">Connecting...</div>  
        <hr>  
        <div class="small">People</div>  
        <ul id="users" class="users-list"></ul>  
        <hr>  
        <div class="small">Typing</div>  
        <div id="typing" class="small"></div>  
        <footer style="margin-top:auto" class="small">  
            Files stored in browser (IndexedDB). Server relays messages only.  
        </footer>  
    </aside>  
</div>  
  
<!-- MOBILE ASIDE -->  
<div id="asideModalOverlay">  
    <div id="asideModal">  
        <button id="closeAsideBtn">Close</button>  
        <div style="margin-top:12px">  
            <div class="small">Connection</div>  
            <div id="m_connStatus" class="small">Connecting...</div>  
            <hr>  
            <div class="small">People</div>  
            <ul id="m_users" class="users-list"></ul>  
            <hr>  
            <div class="small">Typing</div>  
            <div id="m_typing" class="small"></div>  
        </div>  
    </div>  
</div>  
  
<script src="https://cdn.socket.io/4.7.1/socket.io.min.js"></script>  
  
<script>  
/* FIXED FULL JS */  
  
(async function(){  
  
/* Helpers */  
const uid = (p='id') => p+"-"+Date.now()+"-"+Math.random().toString(36).slice(2,8);  
  
const initialsFrom = name =>  
    name ? name.split(" ").map(s=>s[0]).join("").slice(0,2).toUpperCase() : "";  
  
const colorFrom = name=>{  
    if(!name) return "#7c3aed";  
    const colors=['#7c3aed','#0ea5e9','#ef4444','#16a34a','#f97316','#8b5cf6'];  
    let h=0; for(let c of name) h+=c.charCodeAt(0);  
    return colors[h%colors.length];  
};  
  
/* DOM refs */  
const messagesEl = document.getElementById('messages');  
const usersEl = document.getElementById('users');  
const typingEl = document.getElementById('typing');  
const connStatus = document.getElementById('connStatus');  
  
const m_connStatus = document.getElementById('m_connStatus');  
const m_users = document.getElementById('m_users');  
const m_typing = document.getElementById('m_typing');  
  
const nameInput = document.getElementById('nameInput');  
const setNameBtn = document.getElementById('setNameBtn');  
const fileInput = document.getElementById('fileInput');  
const textInput = document.getElementById('textInput');  
const sendBtn = document.getElementById('sendBtn');  
const clearBtn = document.getElementById('clearBtn');  
  
const openAsideBtn = document.getElementById('openAsideBtn');  
const asideOverlay = document.getElementById('asideModalOverlay');  
const closeAsideBtn = document.getElementById('closeAsideBtn');  
const liveBtn = document.getElementById('liveBtn');  
  
const myAvatarEl = document.getElementById('myAvatar');  
const avatarInput = document.getElementById('avatarInput');  
const changePicBtn = document.getElementById('changePicBtn');  
  
openAsideBtn.onclick = ()=> asideOverlay.style.display = "flex";  
closeAsideBtn.onclick = ()=> asideOverlay.style.display = "none";  
liveBtn.onclick = ()=> window.open("https://videostream-ns46.onrender.com/","_blank");  
  
/* Avatar set */  
function setAvatar(dataURL){  
    if(dataURL){  
        myAvatarEl.innerHTML = `<img src="${dataURL}">`;  
    } else {  
        myAvatarEl.textContent = initialsFrom(name);  
        myAvatarEl.style.background = colorFrom(name);  
    }  
}  
  
changePicBtn.onclick = () => avatarInput.click();  
  
avatarInput.onchange = e =>{  
    const f = e.target.files[0];  
    if(!f) return;  
    const reader = new FileReader();  
    reader.onload = ()=>{  
        const dataURL = reader.result;  
        localStorage.setItem("profile_pic_data", dataURL);  
        storedAvatar = dataURL; // keep local var up to date  
        setAvatar(dataURL);  
        if(socket && socket.connected){  
            socket.emit("update-profile",{name, avatar:dataURL});  
        }  
    };  
    reader.readAsDataURL(f);  
};  
  
/* Load profile */  
let name = localStorage.getItem("enhanced_chat_name") || ("User "+Math.floor(Math.random()*9999));  
let storedAvatar = localStorage.getItem("profile_pic_data") || null;  
  
nameInput.value = name;  
setAvatar(storedAvatar);  
  
/* FIXED: Set Name button: set avatar as well and emit profile update */  
setNameBtn.onclick = () =>{  
    name = nameInput.value.trim() || name;  
    localStorage.setItem("enhanced_chat_name", name);  
  
    // refresh avatar shown (use storedAvatar if any)  
    if(storedAvatar){  
        setAvatar(storedAvatar);  
    } else {  
        setAvatar(null);  
    }  
  
    if(socket && socket.connected){  
        socket.emit("update-profile",{name, avatar: storedAvatar});  
    }  
};  
  
/* IndexedDB */  
const DB_NAME="enhanced_chat_db", DB_VER=2; // bump to allow schema changes if needed  
  
function openDb(){  
    return new Promise((res,rej)=>{  
        const r=indexedDB.open(DB_NAME,DB_VER);  
        r.onupgradeneeded=e=>{  
            let db=e.target.result;  
            if(!db.objectStoreNames.contains("messages")){  
                const store = db.createObjectStore("messages",{keyPath:"id"});  
                store.createIndex("ts","ts",{unique:false});  
            }  
            if(!db.objectStoreNames.contains("files")){  
                db.createObjectStore("files",{keyPath:"id"});  
            }  
        };  
        r.onsuccess=()=>res(r.result);  
        r.onerror=()=>rej(r.error);  
    });  
}  
  
async function put(store,obj){  
    const db=await openDb();  
    return new Promise((res,rej)=>{  
        const tx=db.transaction([store],'readwrite');  
        tx.objectStore(store).put(obj);  
        tx.oncomplete=()=>res(obj);  
        tx.onerror=()=>rej(tx.error);  
    });  
}  
  
async function get(store,key){  
    const db=await openDb();  
    return new Promise((res,rej)=>{  
        const tx=db.transaction([store],'readonly');  
        tx.objectStore(store).get(key).onsuccess=e=>res(e.target.result);  
        tx.onerror=()=>rej(tx.error);  
    });  
}  
  
async function getAll(store){  
    const db = await openDb();  
    return new Promise((res,rej)=>{  
        const tx=db.transaction([store],'readonly');  
        const out=[];  
        const req = tx.objectStore(store).openCursor();  
        req.onsuccess=e=>{  
            const cur=e.target.result;  
            if(!cur) return res(out);  
            out.push(cur.value);  
            cur.continue();  
        };  
        req.onerror=()=>rej(req.error);  
    });  
}  
  
async function getFile(id){  
    const db = await openDb();  
    return new Promise((res)=>{  
        db.transaction(["files"],"readonly").objectStore("files")  
            .get(id).onsuccess=e=> res(e.target.result?e.target.result.blob:null);  
    });  
}  
  
/* load history */  
const history = await getAll("messages");  
history.sort((a,b)=>a.ts-b.ts);  
  
/* map of msgId -> DOM element for IntersectionObserver & updates */  
const msgIdToEl = new Map();  
  
// IntersectionObserver to send read receipts when messages enter viewport  
const ioObserver = new IntersectionObserver(entries=>{  
    for(const ent of entries){  
        if(!ent.isIntersecting) continue;  
        const el = ent.target;  
        const msgId = el.getAttribute("data-msgid");  
        if(!msgId) continue;  
        // mark read locally and emit to server  
        markMessageAsReadLocally(msgId, name).catch(console.warn);  
        if(socket && socket.connected){  
            socket.emit("message-read", { msgId, reader: name, ts: Date.now() });  
        }  
        // stop observing after we marked it read for this session (avoid spamming)  
        ioObserver.unobserve(el);  
    }  
},{ threshold: 0.6 });  
  
history.forEach(m=> addMessageDOM(m, {dontObserve:false}));  
  
/* socket io */  
const socket = io();  
  
socket.on("connect",()=>{  
    connStatus.textContent="Connected";  
    m_connStatus.textContent="Connected";  
    socket.emit("join",{name,avatar:storedAvatar});  

    // After connect, announce read receipts for messages currently in view  
    document.querySelectorAll('.msg[data-msgid]').forEach(el=>{  
        const rect = el.getBoundingClientRect();  
        const rootRect = messagesEl.getBoundingClientRect();  
        // quick check if visible in messages viewport  
        if(rect.top < rootRect.bottom && rect.bottom > rootRect.top){  
            const id = el.getAttribute('data-msgid');  
            if(id){  
                markMessageAsReadLocally(id, name).catch(console.warn);  
                socket.emit("message-read", { msgId: id, reader: name, ts: Date.now() });  
                ioObserver.unobserve(el);  
            }  
        }  
    });  
});  
  
socket.on("disconnect",()=>{  
    connStatus.textContent="Disconnected";  
    m_connStatus.textContent="Disconnected";  
});  
  
/* Users */  
let users = {};  
  
function renderUsers(){  
    usersEl.innerHTML="";  
    m_users.innerHTML="";  
  
    for(const id in users){  
        const u = users[id];  
  
        const li=document.createElement("li");  
        li.className="user-item";  
  
        const av=document.createElement("div");  
        av.className="avatar";  
        if(u.avatar){  
            av.innerHTML=`<img src="${u.avatar}">`;  
        } else {  
            av.textContent=initialsFrom(u.name);  
            av.style.background=colorFrom(u.name);  
        }  
  
        const nm=document.createElement("div");  
        nm.textContent = u.name;  
  
        li.append(av,nm);  
  
        usersEl.append(li);  
        m_users.append(li.cloneNode(true));  
    }  
}  
  
socket.on("users-list", data=>{  
    users = data;  
    renderUsers();  
});  
  
socket.on("user-joined", data=>{  
    users[data.id] = data.user;  
    renderUsers();  
    addSystem(`${data.user.name} joined`, data.user);  
});  
  
socket.on("user-left", data=>{  
    delete users[data.id];  
    renderUsers();  
    addSystem(`${data.user.name} left`, data.user);  
});  
  
socket.on("profile-updated",({id,user})=>{  
    users[id]=user;  
    renderUsers();  
});  
  
/* typing */  
let typingTimer=null;  
textInput.oninput=()=>{  
    socket.emit("typing");  
    clearTimeout(typingTimer);  
    typingTimer=setTimeout(()=>socket.emit("stop-typing"),1200);  
};  
  
socket.on("typing",({user})=>{  
    typingEl.textContent=`${user.name} is typing...`;  
    m_typing.textContent=typingEl.textContent;  
});  
socket.on("stop-typing",()=>{  
    typingEl.textContent="—";  
    m_typing.textContent="—";  
});  
  
/* Receive text */  
socket.on("chat-message", async msg=>{  
    // ensure seenBy array exists  
    msg.seenBy = msg.seenBy || [];  
    await put("messages", msg);  
    addMessageDOM(msg);  
});  
  
/* Receive file + PREVIEW */  
socket.on("file-message", async payload=>{  
    // payload.arrayBuffer is expected; create Blob from it  
    try {  
        const blob = new Blob([payload.arrayBuffer], {type:payload.fileType || "application/octet-stream"});  
        await put("files",{id:payload.fileId,blob});  
    } catch (err){  
        console.warn("Error creating/storing blob:", err);  
    }  
  
    const msg={  
        id:payload.id,  
        sender:payload.sender,  
        avatar:payload.avatar,  
        fileId:payload.fileId,  
        fileName:payload.fileName,  
        fileType:payload.fileType,  
        ts:payload.ts,  
        seenBy: payload.seenBy || []  
    };  
  
    await put("messages", msg);  
    addMessageDOM(msg);  
});  
  
/* RECEIVE read receipts from other clients */  
socket.on("message-read", async data => {  
    // data: { msgId, reader, ts }  
    try {  
        const m = await get("messages", data.msgId);  
        if(!m) return;  
        m.seenBy = m.seenBy || [];  
        if(!m.seenBy.includes(data.reader)) m.seenBy.push(data.reader);  
        await put("messages", m);  
        updateSeenUI(data.msgId, m.seenBy);  
    } catch (err){ console.warn("error processing message-read", err); }  
});  
  
/* PREVIEW HANDLER */  
function createPreview(fileName, fileType, blobURL){  
    // fileName shown above preview  
    let nameHTML = `<div class="file-name"></div>`; // replaced dynamically to avoid innerHTML injection  
  
    if(fileType && fileType.startsWith("image/")){  
        return { html: `<img src="${blobURL}" style="max-width:200px;border-radius:6px;margin-top:6px;">`, name: fileName };  
    }  
    if(fileType && fileType.startsWith("video/")){  
        // use <source> for cross-browser compatibility  
        return { html: `<video controls playsinline preload="metadata" style="max-width:200px;margin-top:6px;"><source src="${blobURL}" type="${fileType}">Your browser does not support the video tag.</video>`, name: fileName };  
    }  
    if(fileType && fileType.startsWith("audio/")){  
        return { html: `<audio controls src="${blobURL}" style="margin-top:6px;"></audio>`, name: fileName };  
    }  
    if(fileType === "application/pdf"){  
        return { html: `<iframe src="${blobURL}" style="width:200px;height:200px;border:1px solid orange;margin-top:6px;"></iframe>`, name: fileName };  
    }  
  
    // fallback: show download link with file type and name  
    return { html: `<a class="file-link" href="${blobURL}" download="${encodeURIComponent(fileName || "file")}">Download ${fileName || "file"}</a>`, name: fileName };  
}  
  
/* DOM messages */  
async function addMessageDOM(m, opts={dontObserve:false}){  
    // Avoid re-adding existing message DOM if present (use id)  
    if(document.querySelector(`.msg[data-msgid="${m.id}"]`)) return;  
  
    const box=document.createElement("div");  
    box.className="msg "+(m.out ? "out":"in");  
    box.setAttribute("data-msgid", m.id);  
  
    const av=document.createElement("div");  
    av.className="avatar";  
    if(m.avatar){  
        av.innerHTML=`<img src="${m.avatar}">`;  
    } else {  
        av.textContent=initialsFrom(m.sender);  
        av.style.background=colorFrom(m.sender);  
    }  
  
    // message body container  
    const contentWrap = document.createElement("div");  
    contentWrap.style.display = "flex";  
    contentWrap.style.flexDirection = "column";  
    contentWrap.style.marginLeft = "8px";  
    contentWrap.style.maxWidth = "100%";  
  
    const meta=document.createElement("div");  
    meta.className="meta small";  
    meta.textContent = `${m.sender} · ${new Date(m.ts).toLocaleTimeString()}`;  
  
    const body=document.createElement("div");  
    body.style.marginTop="6px";  
    body.style.wordBreak = "break-word";  
  
    // text message  
    if(m.text){  
        // preserve plain text only  
        const p = document.createElement("div");  
        p.textContent = m.text;  
        body.appendChild(p);  
    }  
  
    // file message preview  
    if(m.fileId){  
        const blob = await getFile(m.fileId);  
        if(blob){  
            const url = URL.createObjectURL(blob);  
            const preview = createPreview(m.fileName, m.fileType, url);  
  
            // insert filename (safe) and download link  
            const nameDiv = document.createElement("div");  
            nameDiv.className = "file-name";  
            const a = document.createElement("a");  
            a.textContent = m.fileName || "file";  
            a.href = url;  
            a.download = m.fileName || "file";  
            a.className = "file-link";  
            nameDiv.appendChild(a);  
  
            // append preview html  
            const wrap = document.createElement("div");  
            wrap.innerHTML = preview.html;  
  
            body.appendChild(nameDiv);  
            body.appendChild(wrap);  
  
            // release object URL when element removed/unloaded  
            // revoke after some time to avoid premature invalidation in some browsers  
            setTimeout(()=>{ try{ URL.revokeObjectURL(url); }catch(e){} }, 60 * 1000);  
        } else {  
            // no blob stored locally - show a placeholder  
            const noDiv = document.createElement("div");  
            noDiv.textContent = m.fileName ? `File: ${m.fileName}` : "File received";  
            body.appendChild(noDiv);  
        }  
    }  
  
    // seen-by row (footer)  
    const seenRow = document.createElement("div");  
    seenRow.className = "meta small system-text";  
    seenRow.style.marginTop = "6px";  
    seenRow.setAttribute("data-seen-for", m.id);  
    const seenList = (m.seenBy && m.seenBy.length) ? `Seen by ${m.seenBy.join(", ")}` : "";  
    seenRow.textContent = seenList;  
  
    // combine parts: avatar + content  
    box.append(av);  
  
    contentWrap.appendChild(meta);  
    contentWrap.appendChild(body);  
    contentWrap.appendChild(seenRow);  
    box.append(contentWrap);  
  
    messagesEl.append(box);  
    messagesEl.scrollTop = messagesEl.scrollHeight;  
  
    // store reference for updates & observe for read marking  
    msgIdToEl.set(m.id, box);  
    if(!opts.dontObserve){  
        ioObserver.observe(box);  
    }  
}  
  
/* System message that can include avatar when user joins/leaves */  
function addSystem(text, user){  
    const box=document.createElement("div");  
    box.className="msg in"; // system messages appear as incoming style  
  
    // create small avatar if user provided  
    const av=document.createElement("div");  
    av.className="avatar";  
    if(user && user.avatar){  
        av.innerHTML = `<img src="${user.avatar}">`;  
    } else if (user && user.name){  
        av.textContent = initialsFrom(user.name);  
        av.style.background = colorFrom(user.name);  
    } else {  
        av.textContent = "S";  
        av.style.background = "#444";  
    }  
  
    const wrapper = document.createElement("div");  
    wrapper.style.display = "flex";  
    wrapper.style.flexDirection = "column";  
    wrapper.style.marginLeft = "8px";  
  
    const meta = document.createElement("div");  
    meta.className = "meta small";  
    meta.textContent = user && user.name ? `${user.name} · ${new Date().toLocaleTimeString()}` : `System · ${new Date().toLocaleTimeString()}`;  
  
    const t = document.createElement("div");  
    t.className = "system-text";  
    t.textContent = text;  
  
    wrapper.appendChild(meta);  
    wrapper.appendChild(t);  
  
    box.appendChild(av);  
    box.appendChild(wrapper);  
  
    messagesEl.appendChild(box);  
    messagesEl.scrollTop = messagesEl.scrollHeight;  
}  
  
/* Update seen UI for a message id */  
function updateSeenUI(msgId, seenByArray){  
    const el = document.querySelector(`.msg[data-msgid="${msgId}"]`);  
    if(!el) return;  
    const seenRow = el.querySelector(`[data-seen-for="${msgId}"]`);  
    if(!seenRow) return;  
    if(!seenByArray || !seenByArray.length){  
        seenRow.textContent = "";  
    } else {  
        // do not show the sender themselves redundantly? Keep as requested (shows names)  
        seenRow.textContent = `Seen by ${seenByArray.join(", ")}`;  
    }  
}  
  
/* mark a message as read locally (store in IndexedDB) */  
async function markMessageAsReadLocally(msgId, readerName){  
    try{  
        const m = await get("messages", msgId);  
        if(!m) return;  
        m.seenBy = m.seenBy || [];  
        if(!m.seenBy.includes(readerName)){  
            m.seenBy.push(readerName);  
            await put("messages", m);  
            updateSeenUI(msgId, m.seenBy);  
        }  
    }catch(err){ console.warn("markMessageAsReadLocally err", err); }  
}  
  
/* send */  
sendBtn.onclick = async () =>{  
    const text=textInput.value.trim();  
    const file=fileInput.files[0];  
  
    if(!text && !file) return;  
  
    /* file */  
    if(file){  
        const arrayBuffer = await file.arrayBuffer();  
        const fileId = uid("file");  
        const msgId = uid("msg");  
  
        const payload={  
            id:msgId,  
            sender:name,  
            avatar:storedAvatar,  
            fileId,  
            fileName:file.name,  
            fileType:file.type,  
            ts:Date.now(),  
            arrayBuffer,  
            seenBy: [name] // sender has seen their own message  
        };  
  
        // store file locally and message locally then emit  
        await put("files",{id:fileId, blob:file});  
        await put("messages",{...payload,out:true});  
        addMessageDOM({...payload,out:true});  
  
        // emit binary-capable payload - socket.io will handle ArrayBuffer  
        socket.emit("file-message",payload);  
    }  
  
    /* text */  
    if(text){  
        const msg={  
            id:uid("msg"),  
            sender:name,  
            avatar:storedAvatar,  
            text,  
            ts:Date.now(),  
            out:true,  
            seenBy: [name] // sender considered to have seen their message  
        };  
        await put("messages",msg);  
        addMessageDOM(msg);  
        socket.emit("chat-message",msg);  
        textInput.value="";  
    }  
  
    fileInput.value="";  
};  
  
/* Clear */  
clearBtn.onclick = async () =>{  
    if(!confirm("Clear local messages?")) return;  
    const db = await openDb();  
    const tx=db.transaction(["messages","files"],"readwrite");  
    tx.objectStore("messages").clear();  
    tx.objectStore("files").clear();  
    tx.oncomplete=()=> messagesEl.innerHTML="";  
};  
  
// when user clicks a message, mark immediately as read (useful for keyboard nav)  
messagesEl.addEventListener('click', e=>{  
    const msgDiv = e.target.closest('.msg[data-msgid]');  
    if(!msgDiv) return;  
    const id = msgDiv.getAttribute('data-msgid');  
    markMessageAsReadLocally(id, name).catch(console.warn);  
    if(socket && socket.connected){ socket.emit("message-read",{ msgId:id, reader:name, ts:Date.now() }); }  
});  
  
// helper: when page unload, try to send final read receipts for visible messages  
window.addEventListener('beforeunload', ()=>{  
    try{  
        document.querySelectorAll('.msg[data-msgid]').forEach(el=>{  
            const id = el.getAttribute('data-msgid');  
            // small heuristic: if seenBy doesn't include me, send last-read  
            const mSeen = (async ()=>{  
                const m = await get('messages', id);  
                if(m && m.seenBy && m.seenBy.includes(name)) return;  
                if(socket && socket.connected){ socket.emit("message-read",{ msgId:id, reader:name, ts:Date.now() }); }  
            })();  
        });  
    }catch(e){}  
});  
  
})();  
</script>  
  
</body>  
</html>