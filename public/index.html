<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CONNECT A lightweight group chat application</title>
<meta name="theme-color" content="teal"/>

<style>
/* --- ORIGINAL CSS (UNTOUCHED) --- */
:root{--bg:#f6f8fb;--card:#fff;--accent:#2563eb;--muted:#666}
html,body{height:100%;margin:0;font-family:georgia;background:var(--bg);color:teal;margin-top:1px;}
.app{max-width:1000px;margin:0 auto;height:100vh;border-radius:4px;overflow:hidden;grid-template-columns:1fr 320px;border:1px solid orange;}
.left{display:flex;flex-direction:column;height:100%;background:linear-gradient(to right, teal, maroon);}
header{padding:12px 16px;border-bottom:1px solid orange;align-items:center;gap:12px;color:teal;flex-shrink:0;}
.logo{font-weight:600;color:orange;font-size:26px}
.messages{flex:1;overflow-y:auto;padding:16px;display:flex;flex-direction:column;gap:8px;background:teal;}
.composer{border-top:1px solid orange;display:flex;gap:8px;align-items:center;padding:8px;flex-shrink:0;background:linear-gradient(to right,#ffffff55,#ffffff00)}
textarea{height:64px;border:1px solid orange;resize:none;padding:8px;border-radius:6px;width:100%;color:orange;background:maroon;}
button{background:orange;color:teal;border:1px solid gray;padding:6px 8px;border-radius:8px;cursor:pointer}
.right{padding:12px;background:#f0f0f0;border-left:1px solid teal;display:flex;flex-direction:column;gap:8px;height:100%;overflow:auto}
.avatar{width:50px;height:50px;border-radius:50%;overflow:hidden;background:#7c3aed;color:white;display:flex;align-items:center;justify-content:center;font-weight:600;border:1px solid orange;}
.avatar img{width:100%;height:100%;object-fit:cover;}
.msg{max-width:70%;padding:10px;border-radius:10px;background:gray;border:1px solid orange;color: orange;}
.msg.out{margin-left:auto;background:orange;border:1px solid white;color:teal;}
.meta.small{font-size:12px;color:var(--muted)}
.users-list{list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:8px}
.user-item{display:flex;align-items:center;gap:8px;padding:6px;border-radius:8px}
.small{font-size:13px;color:var(--muted)}
#asideModalOverlay{position:fixed;left:0;top:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.55);z-index:999}
#asideModal{background:gray;width:92%;max-width:360px;max-height:90vh;overflow:auto;border-radius:8px;padding:14px;border:1px solid orange;}
#closeAsideBtn{background:maroon;color:orange;width:100%;padding:10px;border-radius:5px;border:1px solid orange;}
@media(max-width:720px){.app{grid-template-columns:1fr;height:100vh;border-radius:0}.right{display:none}}
.file-link{display:inline-block;margin-top:6px;color:var(--accent);text-decoration:underline;cursor:pointer}
.picturee{width:30px;height:30px;border:1px solid orange;border-radius:20px;padding:1px;margin-top:6px;}
</style>
</head>

<body>
<div class="app">

    <!-- LEFT -->
    <div class="left">
        <header>
            <span class="logo">Connect</span>
            <button id="openAsideBtn" class="small">Status</button>
            <button id="liveBtn" class="small">Live Video Streaming</button>
            <div style="flex:1"></div>

            <div class="user" style="display:flex;align-items:center;gap:8px">
                <div id="myAvatar" class="avatar">A</div>
                <input id="avatarInput" type="file" accept="image/*" style="display:none">
                <button id="changePicBtn" class="small">Image</button>

                <input id="nameInput" placeholder="Your name"
                       style="padding:6px;border-radius:6px;border:1px solid orange;">
                <button id="setNameBtn" class="small">Set</button>
            </div>
        </header>

        <div id="messages" class="messages"></div>

        <div class="composer">
            <textarea id="textInput" placeholder="Write a message..."></textarea>
            <div style="display:flex;flex-direction:column;gap:6px">
                <button id="sendBtn">Send</button>
                <button id="clearBtn" class="small">Clear</button>
            </div>
        </div>

        <input id="fileInput" type="file"
               style="color:orange;font-size:10px;background:gray;border-radius:4px;border:1px solid orange; padding:4px; margin:8px; text-align:center;">
    </div>

    <!-- RIGHT -->
    <aside class="right">
        <div class="small">Connection</div>
        <div id="connStatus" class="small">Connecting...</div>
        <hr>
        <div class="small">People</div>
        <ul id="users" class="users-list"></ul>
        <hr>
        <div class="small">Typing</div>
        <div id="typing" class="small"></div>
    </aside>
</div>

<script src="https://cdn.socket.io/4.7.1/socket.io.min.js"></script>

<script>
(async function(){

/*--------------------------------------------------------------------
 FIX: Read Receipts Loop + Throttle
--------------------------------------------------------------------*/
const readMessages = new Set();      // Prevent duplicate sending
let lastEmitTime = 0;

/* Emits only once per message ID */
function sendReadReceipt(id){
    const now = Date.now();
    if(readMessages.has(id)) return;
    if(now - lastEmitTime < 1000) return;   // slow down spam

    readMessages.add(id);
    lastEmitTime = now;
    socket.emit("message-read", { id, reader:name });
}

/*--------------------------------------------------------------------
 CORE APP CODE (UNCHANGED EXCEPT WHERE NEEDED)
--------------------------------------------------------------------*/
const uid = (p='id') => p+"-"+Date.now()+"-"+Math.random().toString(36).slice(2,8);

const initialsFrom = name =>
    name ? name.split(" ").map(s=>s[0]).join("").slice(0,2).toUpperCase() : "";

const colorFrom = name=>{
    if(!name) return "#7c3aed";
    const colors=['#7c3aed','#0ea5e9','#ef4444','#16a34a','#f97316','#8b5cf6'];
    let h=0; for(let c of name) h+=c.charCodeAt(0);
    return colors[h%colors.length];
};

/* DOM refs */
const messagesEl = document.getElementById('messages');
const usersEl = document.getElementById('users');
const typingEl = document.getElementById('typing');
const connStatus = document.getElementById('connStatus');

const nameInput = document.getElementById('nameInput');
const setNameBtn = document.getElementById('setNameBtn');
const fileInput = document.getElementById('fileInput');
const textInput = document.getElementById('textInput');
const sendBtn = document.getElementById('sendBtn');
const clearBtn = document.getElementById('clearBtn');
const avatarInput = document.getElementById('avatarInput');
const changePicBtn = document.getElementById('changePicBtn');
const myAvatarEl = document.getElementById('myAvatar');

let name = localStorage.getItem("enhanced_chat_name") || ("User "+Math.floor(Math.random()*9999));
let storedAvatar = localStorage.getItem("profile_pic_data") || null;

nameInput.value = name;

function setAvatar(a){
    if(a){
        myAvatarEl.innerHTML = `<img src="${a}">`;
    } else {
        myAvatarEl.textContent = initialsFrom(name);
        myAvatarEl.style.background = colorFrom(name);
    }
}
setAvatar(storedAvatar);

/* SET button now updates avatar correctly */
setNameBtn.onclick = ()=>{
    name = nameInput.value.trim() || name;
    localStorage.setItem("enhanced_chat_name", name);
    setAvatar(storedAvatar);
    socket.emit("update-profile",{ name, avatar:storedAvatar });
};

/* Avatar upload */
changePicBtn.onclick = ()=> avatarInput.click();
avatarInput.onchange = e=>{
    const f = e.target.files[0];
    if(!f) return;
    const reader = new FileReader();
    reader.onload = ()=>{
        storedAvatar = reader.result;
        localStorage.setItem("profile_pic_data", storedAvatar);
        setAvatar(storedAvatar);
        socket.emit("update-profile",{ name, avatar:storedAvatar });
    };
    reader.readAsDataURL(f);
};

/* IndexedDB */
const DB_NAME="enhanced_chat_db", DB_VER=1;

function openDb(){
    return new Promise((res,rej)=>{
        const r=indexedDB.open(DB_NAME,DB_VER);
        r.onupgradeneeded=e=>{
            let db=e.target.result;
            if(!db.objectStoreNames.contains("messages"))
                db.createObjectStore("messages",{keyPath:"id"});
            if(!db.objectStoreNames.contains("files"))
                db.createObjectStore("files",{keyPath:"id"});
        };
        r.onsuccess=()=>res(r.result);
    });
}

async function put(store,obj){
    const db=await openDb();
    return new Promise(res=>{
        const tx=db.transaction([store],'readwrite');
        tx.objectStore(store).put(obj);
        tx.oncomplete=()=>res();
    });
}

async function getFile(id){
    const db=await openDb();
    return new Promise(res=>{
        db.transaction(["files"],"readonly")
          .objectStore("files")
          .get(id).onsuccess=e=> res(e.target.result ? e.target.result.blob : null);
    });
}

/* Load history */
const allMsgs = await new Promise(async res=>{
    const db=await openDb();
    const arr=[];
    const tx=db.transaction(["messages"],"readonly");
    tx.objectStore("messages").openCursor().onsuccess=e=>{
        const cur=e.target.result;
        if(!cur) return res(arr);
        arr.push(cur.value);
        cur.continue();
    };
});

allMsgs.sort((a,b)=>a.ts-b.ts).forEach(addMessageDOM);

/* socket */
const socket = io();

socket.on("connect",()=>{
    connStatus.textContent="Connected";
    socket.emit("join",{name,avatar:storedAvatar});
});

/* user lists */
let users={};

function renderUsers(){
    usersEl.innerHTML="";
    for(const id in users){
        const u=users[id];
        const li=document.createElement("li");
        li.className="user-item";

        const av=document.createElement("div");
        av.className="avatar";
        if(u.avatar){
            av.innerHTML=`<img src="${u.avatar}">`;
        } else {
            av.textContent=initialsFrom(u.name);
            av.style.background=colorFrom(u.name);
        }

        const nm=document.createElement("div");
        nm.textContent = u.name;

        li.append(av,nm);
        usersEl.append(li);
    }
}

socket.on("users-list", u=>{ users=u; renderUsers(); });
socket.on("user-joined", d=>{ users[d.id]=d.user; renderUsers(); addSystem(`${d.user.name} joined`); });
socket.on("user-left", d=>{ delete users[d.id]; renderUsers(); addSystem(`${d.user.name} left`); });
socket.on("profile-updated",({id,user})=>{ users[id]=user; renderUsers(); });

/* typing */
let typingTimer=null;
textInput.oninput=()=>{
    socket.emit("typing");
    clearTimeout(typingTimer);
    typingTimer=setTimeout(()=>socket.emit("stop-typing"),1300);
};
socket.on("typing",({user})=> typingEl.textContent=`${user.name} is typing...`);
socket.on("stop-typing",()=> typingEl.textContent="");

/* receive text */
socket.on("chat-message", async msg=>{
    await put("messages",msg);
    addMessageDOM(msg);
});

/* receive files */
socket.on("file-message", async payload=>{
    const blob=new Blob([payload.arrayBuffer],{type:payload.fileType});
    await put("files",{id:payload.fileId,blob});
    await put("messages",payload);
    addMessageDOM(payload);
});

/* read receipt received from OTHER users */
socket.on("message-read", ({id,reader})=>{
    addSystem(`${reader} read message`);
});

/* show messages */
async function addMessageDOM(m){
    const box=document.createElement("div");
    box.className="msg "+(m.out?"out":"in");

    const av=document.createElement("div");
    av.className="avatar";

    if(m.avatar){
        av.innerHTML=`<img src="${m.avatar}">`;
    } else {
        av.textContent=initialsFrom(m.sender);
        av.style.background=colorFrom(m.sender);
    }

    box.append(av);

    const meta=document.createElement("div");
    meta.className="meta small";
    meta.textContent = `${m.sender} · ${new Date(m.ts).toLocaleTimeString()}`;

    const body=document.createElement("div");
    body.style.marginTop="6px";

    if(m.text) body.textContent = m.text;

    if(m.fileId){
        const blob = await getFile(m.fileId);
        if(blob){
            const url=URL.createObjectURL(blob);

            /* FIX: show filename */
            const nameTag = document.createElement("div");
            nameTag.style.fontSize="12px";
            nameTag.style.color="orange";
            nameTag.textContent = m.fileName;
            body.append(nameTag);

            if(m.fileType.startsWith("image/")){
                body.innerHTML += `<img src="${url}" style="max-width:200px;margin-top:6px;border-radius:6px;">`;
            } else if(m.fileType.startsWith("video/")){
                body.innerHTML += `<video src="${url}" controls style="max-width:200px;margin-top:6px"></video>`;
            } else if(m.fileType.startsWith("audio/")){
                body.innerHTML += `<audio controls src="${url}" style="margin-top:6px"></audio>`;
            } else {
                body.innerHTML += `<a href="${url}" download="${m.fileName}" class="file-link">${m.fileName}</a>`;
            }
        }
    }

    box.append(meta, body);
    messagesEl.append(box);

    messagesEl.scrollTop = messagesEl.scrollHeight;

    /*  When message visible  mark as read (but only once per message) */
    if(!m.out){
        sendReadReceipt(m.id);
    }
}

/* system */
function addSystem(t){
    addMessageDOM({
        id:uid("sys"),
        sender:"System",
        text:t,
        ts:Date.now()
    });
}

/* send */
sendBtn.onclick = async ()=>{
    const text=textInput.value.trim();
    const file=fileInput.files[0];
    if(!text && !file) return;

    /* sending file */
    if(file){
        const arrayBuffer = await file.arrayBuffer();
        const payload={
            id:uid("msg"),
            sender:name,
            avatar:storedAvatar,
            fileId:uid("file"),
            fileName:file.name,
            fileType:file.type,
            ts:Date.now(),
            arrayBuffer,
            out:true
        };

        await put("files",{id:payload.fileId, blob:file});
        await put("messages",payload);
        addMessageDOM(payload);

        socket.emit("file-message",payload);
    }

    /* send text */
    if(text){
        const msg={
            id:uid("msg"),
            sender:name,
            avatar:storedAvatar,
            text,
            ts:Date.now(),
            out:true
        };
        await put("messages",msg);
        addMessageDOM(msg);
        socket.emit("chat-message",msg);
        textInput.value="";
    }

    fileInput.value="";
};

/* clear */
clearBtn.onclick = async()=>{
    if(!confirm("Clear local messages?")) return;
    const db=await openDb();
    db.transaction(["messages","files"],"readwrite").objectStore("messages").clear();
    db.transaction(["messages","files"],"readwrite").objectStore("files").clear();
    messagesEl.innerHTML="";
};

})();
</script>
</body>
</html>